import os
import json
import argparse
import datetime
import sys
import shutil
import statistics
import filecmp
import subprocess
from argparse import RawTextHelpFormatter

# --- CONFIG LOAD ---
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
CONFIG_PATH = os.path.join(SCRIPT_DIR, "..", "Config", "config.json")

if not os.path.exists(CONFIG_PATH):
    print("‚ùå CRITICAL ERROR: Config file not found.")
    sys.exit(1)

with open(CONFIG_PATH, "r") as f:
    CONFIG = json.load(f)

ROOT_PATH = CONFIG["root_path"]
PROJECTS_PATH = CONFIG["projects_path"]
EXPORTS_PATH = CONFIG["exports_path"]
TEMPLATES_PATH = CONFIG["templates_path"]
VAULT_PATH = CONFIG["vault_path"]
DOWNLOADS_PATH = CONFIG.get("downloads_path", os.path.join(os.path.expanduser("~"), "Downloads"))

# --- HELPERS ---

def get_date_slug(override_date=None):
    if override_date: return override_date
    return datetime.datetime.now().strftime("%Y-%m-%d")

def get_export_month_path():
    now = datetime.datetime.now()
    year = now.strftime("%Y")
    month_name = now.strftime("%B")
    month_num = now.strftime("%m")
    
    full_path = os.path.join(EXPORTS_PATH, year, f"{month_num} - {month_name}")
    if not os.path.exists(full_path): os.makedirs(full_path)
    return full_path

def find_meta_in_cwd():
    current = os.getcwd()
    for _ in range(3):
        if ".project_meta.json" in os.listdir(current):
            try:
                with open(os.path.join(current, ".project_meta.json"), "r", encoding="utf-8-sig") as f:
                    return json.load(f), current
            except: return None, None
        current = os.path.dirname(current)
        if len(current) < 4: break
    return None, None

def get_smart_date(path):
    if os.path.isfile(path): return os.path.getmtime(path)
    timestamps = []
    for root, _, files in os.walk(path):
        for file in files:
            if not file.startswith('.'):
                try: timestamps.append(os.path.getmtime(os.path.join(root, file)))
                except: pass
    if not timestamps: return os.path.getmtime(path)
    return statistics.median(timestamps)

def sync_two_folders(dir_a, dir_b):
    if not os.path.exists(dir_a): os.makedirs(dir_a)
    if not os.path.exists(dir_b): os.makedirs(dir_b)

    files_a = set(f for f in os.listdir(dir_a) if f.endswith(".md"))
    files_b = set(f for f in os.listdir(dir_b) if f.endswith(".md"))
    all_files = files_a.union(files_b)
    logs = []

    for filename in all_files:
        path_a = os.path.join(dir_a, filename)
        path_b = os.path.join(dir_b, filename)

        if filename in files_a and filename not in files_b:
            try:
                shutil.copy2(path_a, path_b)
                logs.append(f"  [‚Üí] Pushed to Vault: {filename}")
            except Exception as e: logs.append(f"  ‚ùå Error pushing: {e}")
        elif filename in files_b and filename not in files_a:
            try:
                shutil.copy2(path_b, path_a)
                logs.append(f"  [‚Üê] Pulled from Vault: {filename}")
            except Exception as e: logs.append(f"  ‚ùå Error pulling: {e}")
        else:
            try:
                if not filecmp.cmp(path_a, path_b, shallow=False):
                    if os.path.getmtime(path_a) > os.path.getmtime(path_b):
                        shutil.copy2(path_a, path_b)
                        logs.append(f"  [‚Üí] Updated Vault: {filename}")
                    elif os.path.getmtime(path_b) > os.path.getmtime(path_a):
                        shutil.copy2(path_a, path_a + ".bak")
                        shutil.copy2(path_b, path_a)
                        logs.append(f"  [‚Üê] Updated Project (Backup made): {filename}")
            except Exception as e: logs.append(f"  ‚ùå Error syncing: {e}")
    return logs

def setup_git(project_path, category):
    if category.lower() not in ["code", "web", "ai"]: return # Manual flag handled in main logic
    print("   üîß Initializing Git Repository...")
    try:
        subprocess.run(["git", "init"], cwd=project_path, check=True, stdout=subprocess.DEVNULL)
        gitignore_dest = os.path.join(project_path, ".gitignore")
        with open(gitignore_dest, "w") as f:
            f.write("# CreativeOS Auto-Gitignore\nnode_modules/\n__pycache__/\n.env\n.DS_Store\n")
    except Exception as e:
        print(f"   ‚ùå Git init failed: {e}")

# --- COMMANDS ---

def cmd_new(args):
    project_name = args.name
    category = args.category.title()
    date_prefix = get_date_slug(args.date)
    safe_name = project_name.replace(" ", "_")
    slug = f"{date_prefix}_{safe_name}"
    
    cwd = os.getcwd()
    if args.client:
        target_root = os.path.join(PROJECTS_PATH, "Clients", args.client)
        if not os.path.exists(target_root):
            os.makedirs(target_root)
            print(f"‚ú® Created new Client folder: {args.client}")
    elif cwd.startswith(PROJECTS_PATH):
        target_root = cwd
    else:
        if category.lower() in ["web", "code"]: phys_cat = "Code"
        elif category.lower() in ["music", "audio"]: phys_cat = "Music"
        elif category.lower() == "ai": phys_cat = "AI"
        else: phys_cat = "Video"
        target_root = os.path.join(PROJECTS_PATH, phys_cat)

    target_dir = os.path.join(target_root, slug)
    if os.path.exists(target_dir):
        print(f"‚ö†Ô∏è  Project already exists: {target_dir}")
        return

    cat_lower = category.lower()
    if args.simple: template_name = "simple"
    elif cat_lower == "code": template_name = "plain_code"
    elif cat_lower == "web": template_name = "code_project"
    elif cat_lower in ["music", "audio"]: template_name = "audio_project"
    elif cat_lower == "ai": template_name = "ai_project"
    else: template_name = "video_project"
    
    template_file = os.path.join(TEMPLATES_PATH, template_name, "structure.json")
    if not os.path.exists(template_file):
        print(f"‚ùå Template not found: {template_name}")
        return
        
    with open(template_file, "r") as f: structure = json.load(f)

    print(f"üî® Creating project: {slug}")
    os.makedirs(target_dir)
    for folder, contents in structure.items():
        folder_path = os.path.join(target_dir, folder)
        os.makedirs(folder_path, exist_ok=True)
        for item in contents:
            if "." in item:
                if not os.path.exists(os.path.join(folder_path, item)):
                    with open(os.path.join(folder_path, item), "w") as f:
                        f.write(f"# {item}\nProject: {project_name}\nCreated: {date_prefix}\n")
            else: os.makedirs(os.path.join(folder_path, item), exist_ok=True)

    meta_client = "None"
    if args.client: meta_client = args.client
    else:
        norm_path = target_root.replace("\\", "/")
        parts = norm_path.split("/")
        if "Clients" in parts:
            try: meta_client = parts[parts.index("Clients") + 1]
            except: pass

    # Notes with YAML
    notes_dir = os.path.join(target_dir, "00_Notes")
    os.makedirs(notes_dir, exist_ok=True)
    if not os.path.exists(os.path.join(notes_dir, "Idea.md")):
        with open(os.path.join(notes_dir, "Idea.md"), "w") as f:
            f.write(f"---\ntype: project\ncategory: {category}\nclient: {meta_client}\nstatus: active\ncreated: {date_prefix}\n---\n\n# {project_name}\n")

    meta = {
        "name": project_name, "slug": slug, "type": category,
        "created": date_prefix, "client": meta_client,
        "template": template_name, "root": target_dir
    }
    with open(os.path.join(target_dir, ".project_meta.json"), "w") as f:
        json.dump(meta, f, indent=4)
        
    if cat_lower in ["code", "web", "ai"]: setup_git(target_dir, category)
    print(f"‚úÖ Spawned at: {target_dir}")

def cmd_clone(args):
    """Clones a git repo and adopts it into CreativeOS."""
    url = args.url
    # Extract name from URL (e.g., 'repo.git' -> 'repo')
    repo_name = url.split("/")[-1].replace(".git", "")
    
    # Use "Code" as default category for clones unless specified
    category = args.category.title() if args.category != "Video" else "Code"
    date_prefix = get_date_slug(args.date)
    
    # We enforce the date prefix for sorting, even on clones
    slug = f"{date_prefix}_{repo_name}"
    
    # --- Location Logic (Same as cmd_new) ---
    cwd = os.getcwd()
    if args.client:
        target_root = os.path.join(PROJECTS_PATH, "Clients", args.client)
        if not os.path.exists(target_root):
            os.makedirs(target_root)
            print(f"‚ú® Created new Client folder: {args.client}")
    elif cwd.startswith(PROJECTS_PATH):
        target_root = cwd
    else:
        # Default map
        if category.lower() in ["web", "code"]: phys_cat = "Code"
        elif category.lower() in ["music", "audio"]: phys_cat = "Music"
        elif category.lower() == "ai": phys_cat = "AI"
        else: phys_cat = "Video" # Fallback
        target_root = os.path.join(PROJECTS_PATH, phys_cat)

    target_dir = os.path.join(target_root, slug)
    
    if os.path.exists(target_dir):
        print(f"‚ö†Ô∏è  Target folder exists: {target_dir}")
        return

    print(f"‚¨áÔ∏è  Cloning: {repo_name}...")
    print(f"   To: {target_dir}")
    
    try:
        # Run Git Clone
        subprocess.run(["git", "clone", url, target_dir], check=True)
        
        # --- Post-Processing (Make it a CreativeOS Project) ---
        
        # 1. Notes
        notes_dir = os.path.join(target_dir, "00_Notes")
        os.makedirs(notes_dir, exist_ok=True)
        
        # Determine Client for Metadata
        meta_client = "None"
        if args.client: meta_client = args.client
        else:
            norm_path = target_root.replace("\\", "/")
            parts = norm_path.split("/")
            if "Clients" in parts:
                try: meta_client = parts[parts.index("Clients") + 1]
                except: pass

        if not os.path.exists(os.path.join(notes_dir, "Idea.md")):
            with open(os.path.join(notes_dir, "Idea.md"), "w") as f:
                f.write(f"---\ntype: project\ncategory: {category}\nclient: {meta_client}\nstatus: active\ncreated: {date_prefix}\nsource: {url}\n---\n\n# {repo_name}\n")

        # 2. Metadata
        meta = {
            "name": repo_name,
            "slug": slug,
            "type": category,
            "created": date_prefix,
            "client": meta_client,
            "template": "git_clone",
            "root": target_dir,
            "repo_url": url
        }
        with open(os.path.join(target_dir, ".project_meta.json"), "w") as f:
            json.dump(meta, f, indent=4)
            
        print(f"‚úÖ Clone Complete & Adopted!")
        
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Git Clone Failed: {e}")
    except Exception as e:
        print(f"‚ùå Error during adoption: {e}")

def cmd_init(args):
    cwd = os.getcwd()
    if not cwd.startswith(PROJECTS_PATH):
        print("‚ö†Ô∏è  Not in CreativeOS Projects folder.")
        if input("Proceed? (y/n): ").lower() != 'y': return

    if os.path.exists(os.path.join(cwd, ".project_meta.json")):
        print("‚úÖ Already initialized.")
        return

    print(f"ü™Ñ Initializing: {os.path.basename(cwd)}...")
    smart_ts = get_smart_date(cwd)
    date_str = datetime.datetime.fromtimestamp(smart_ts).strftime("%Y-%m-%d")
    
    current_name = os.path.basename(cwd)
    norm_path = cwd.replace("\\", "/")
    parts = norm_path.split("/")
    
    meta_client = "None"
    category = "Video"
    if "Clients" in parts:
        try: meta_client = parts[parts.index("Clients") + 1]
        except: pass
    elif "Video" in parts:
        try: 
            if len(parts) > parts.index("Video") + 2: meta_client = parts[parts.index("Video") + 1]
        except: pass
    
    if "Code" in parts: category = "Code"
    elif "Music" in parts: category = "Music"
    elif "AI" in parts: category = "AI"

    notes_dir = os.path.join(cwd, "00_Notes")
    os.makedirs(notes_dir, exist_ok=True)
    if not os.path.exists(os.path.join(notes_dir, "Idea.md")):
        with open(os.path.join(notes_dir, "Idea.md"), "w") as f:
            f.write(f"---\ntype: project\ncategory: {category}\nclient: {meta_client}\nstatus: active\ncreated: {date_str}\n---\n\n# {current_name}\n")

    slug = f"{date_str}_{current_name.replace(' ', '_')}"
    meta = {
        "name": current_name, "slug": slug, "type": category,
        "created": date_str, "client": meta_client,
        "template": "adopted_existing", "root": cwd
    }
    with open(os.path.join(cwd, ".project_meta.json"), "w") as f:
        json.dump(meta, f, indent=4)
    print(f"‚úÖ Project adopted! Slug: {slug}")

def cmd_export(args):
    month_path = get_export_month_path()
    meta, project_root = find_meta_in_cwd()
    if meta and not args.simple:
        path = os.path.join(month_path, meta["slug"])
        for s in ["Video", "Thumbnail", "Audio"]: os.makedirs(os.path.join(path, s), exist_ok=True)
        print(f"üìÇ Project Export: {path}")
        os.startfile(path)
    else:
        print(f"üìÇ Month Export: {month_path}")
        os.startfile(month_path)

def cmd_sync(args):
    print("üß† Syncing CreativeOS Brain (Bidirectional)...")
    vault_projects_dir = os.path.join(VAULT_PATH, "01_Active_Projects")
    if not os.path.exists(vault_projects_dir): os.makedirs(vault_projects_dir)

    total_changes = 0
    for root, dirs, files in os.walk(PROJECTS_PATH):
        if ".project_meta.json" in files:
            meta_path = os.path.join(root, ".project_meta.json")
            try:
                with open(meta_path, "r", encoding="utf-8-sig") as f: meta = json.load(f)
            except: continue
            
            project_name = meta.get("slug", "Unknown")
            notes_project = os.path.join(root, "00_Notes")
            notes_vault = os.path.join(vault_projects_dir, project_name)

            logs = sync_two_folders(notes_project, notes_vault)
            if logs:
                print(f"‚ö° {project_name}:")
                for log in logs: print(log)
                total_changes += len(logs)
    print(f"‚ú® Brain Sync Complete. {synced_count} projects updated." if 'synced_count' in locals() else f"‚ú® Sync Complete. {total_changes} operations.")

def cmd_thumbs(args):
    print("üñºÔ∏è  Spinning up Thumbnail Mirror...")
    gallery_root = os.path.join(ROOT_PATH, "04_Global_Assets", "Thumbnails_Mirror")
    if not os.path.exists(gallery_root): os.makedirs(gallery_root)
    
    count = 0
    for root, dirs, files in os.walk(PROJECTS_PATH):
        if "02_Assets" in dirs:
            thumb_source = os.path.join(root, "02_Assets", "Thumbnails")
            if os.path.exists(thumb_source):
                project_name = os.path.basename(root)
                if ".project_meta.json" in files:
                    try:
                        with open(os.path.join(root, ".project_meta.json"), "r", encoding="utf-8-sig") as f:
                            meta = json.load(f)
                            project_name = meta.get("slug", project_name)
                    except: pass
                
                for img in os.listdir(thumb_source):
                    if img.lower().endswith(('.png', '.jpg', '.jpeg', '.webp')):
                        src_file = os.path.join(thumb_source, img)
                        ts = os.path.getmtime(src_file)
                        date_str = datetime.datetime.fromtimestamp(ts).strftime("%Y-%m-%d")
                        new_name = f"{date_str}_{project_name}_{img}"
                        dst_file = os.path.join(gallery_root, new_name)
                        if not os.path.exists(dst_file):
                            shutil.copy2(src_file, dst_file)
                            count += 1
                            print(f"  -> Mirrored: {new_name}")
    print(f"‚ú® Gallery Updated. {count} new thumbnails.")
    os.startfile(gallery_root)

def cmd_clean(args):
    target = args.target if args.target else DOWNLOADS_PATH
    print(f"üßπ Cleaning: {target}...")
    if not os.path.exists(target):
        print(f"‚ùå Error: Path not found: {target}")
        return
    MAPPING = {
        "_Images": [".jpg", ".jpeg", ".png", ".gif", ".webp", ".svg"],
        "_Video": [".mp4", ".mov", ".avi", ".mkv"],
        "_Audio": [".mp3", ".wav", ".aac"],
        "_Docs": [".pdf", ".docx", ".txt", ".xlsx", ".pptx"],
        "_Installers": [".exe", ".msi", ".iso"],
        "_Archives": [".zip", ".rar", ".7z", ".tar", ".gz"]
    }
    count = 0
    for item in os.listdir(target):
        item_path = os.path.join(target, item)
        if os.path.isfile(item_path) and not item.startswith("."):
            ext = os.path.splitext(item)[1].lower()
            for folder, extensions in MAPPING.items():
                if ext in extensions:
                    dest_dir = os.path.join(target, folder)
                    if not os.path.exists(dest_dir): os.makedirs(dest_dir)
                    try:
                        shutil.move(item_path, os.path.join(dest_dir, item))
                        count += 1
                        print(f"  -> Moved {item} to {folder}")
                    except: pass
                    break
    print(f"‚ú® Cleanup Complete. {count} files moved.")
    os.startfile(target)

def cmd_sort_exports(args):
    inbox_path = os.path.join(EXPORTS_PATH, "_Inbox")
    if not os.path.exists(inbox_path):
        os.makedirs(inbox_path)
        print(f"‚ú® Created Inbox.")
        os.startfile(inbox_path)
        return
    print(f"üóÇÔ∏è  Sorting Inbox...")
    if not os.listdir(inbox_path):
        print("‚úÖ Inbox is empty.")
        return
    count = 0
    for item in os.listdir(inbox_path):
        src_path = os.path.join(inbox_path, item)
        smart_ts = get_smart_date(src_path)
        date_obj = datetime.datetime.fromtimestamp(smart_ts)
        year = date_obj.strftime("%Y")
        month_folder = date_obj.strftime("%m - %B")
        dest_dir = os.path.join(EXPORTS_PATH, year, month_folder)
        
        dest_path = os.path.join(dest_dir, item)
        parent = os.path.dirname(dest_path)
        if not os.path.exists(parent): os.makedirs(parent)
        
        base, ext = os.path.splitext(dest_path)
        ctr = 2
        while os.path.exists(dest_path):
            dest_path = f"{base}_v{ctr}{ext}"
            ctr += 1
            
        try:
            shutil.move(src_path, dest_path)
            count += 1
            print(f"  -> Filed: {item} -> {year}/{month_folder}")
        except: pass
    print(f"‚ú® Sorted {count} items.")

def cmd_resurrect(args):
    # This assumes the archive path is in config or defined
    ARCHIVE_PATH = CONFIG.get("archive_path", "D:\\OneDrive - Developer\\Archive")
    print(f"üïØÔ∏è  Searching Archive: {ARCHIVE_PATH} for '{args.name}'...")
    if not os.path.exists(ARCHIVE_PATH):
        print("‚ùå Archive path not found.")
        return
    matches = []
    for root, dirs, files in os.walk(ARCHIVE_PATH):
        for d in dirs:
            if args.name.lower() in d.lower():
                matches.append(os.path.join(root, d))
        if root.count(os.sep) - ARCHIVE_PATH.count(os.sep) > 1: del dirs[:]
    
    if not matches:
        print("‚ùå No matching projects found.")
        return
    
    selected_path = matches[0]
    if len(matches) > 1:
        print("üîç Multiple matches:")
        for i, m in enumerate(matches): print(f"   {i+1}. {m}")
        try: selected_path = matches[int(input("Select: ")) - 1]
        except: return

    print(f"‚ö∞Ô∏è  Resurrecting: {os.path.basename(selected_path)}")
    # Simplified logic: Default to Video/Clients based on existing logic
    dest_root = os.path.join(PROJECTS_PATH, "Video")
    # ... (Deep logic omitted for brevity, assuming standard move)
    shutil.move(selected_path, dest_root)
    print(f"‚ú® LIVE! Moved to {dest_root}")

def cmd_travel(args):
    SHUTTLE_PATH = CONFIG.get("shuttle_path", "F:\\CreativeOS_Shuttle")
    meta, project_root = find_meta_in_cwd()
    if not meta:
        print("‚ùå Not inside a project.")
        return
    if not os.path.exists(SHUTTLE_PATH):
        print("‚ùå Shuttle drive not found.")
        return
    
    rel = os.path.relpath(project_root, PROJECTS_PATH)
    dest = os.path.join(SHUTTLE_PATH, "Projects", rel)
    print(f"üöÄ Launching to Shuttle: {dest}")
    if input("Start copy? (y/n): ").lower() == 'y':
        try:
            shutil.copytree(project_root, dest, dirs_exist_ok=True)
            print("‚úÖ Copied.")
        except Exception as e: print(f"‚ùå Error: {e}")

def main():
    banner = r"""
   ______                _   _            ___  ____ 
  / ____/________  ____ | | | |__   ___  / _ \/ ___|
 | |   | '__/ _ \/ _` || |_| |\ \ / / _ \| | | \___ \
 | |___| | |  __/ (_| ||  _  | \ V /  __/ |_| |___) |
  \____|_|  \___|\__,_||_| |_|  \_/ \___|\___/|____/ 
    """
    
    help_text = f"""{banner}
    The Central Nervous System for your Creative Workflow. (v2.0)
    ============================================================

    1. CREATION
    -----------
    cos new "Name" [flags]
        Creates a new project. Context-aware.
        Flags: -c (Category: Video, Code, Web, AI), -s (Simple), --client "Name"
    
    cos clone <url> [flags]
        Clones a Git Repo and adopts it into CreativeOS structure.
        Flags: -c (Category), --client "Name".
        Example: cos clone https://github.com/user/repo -c AI

    cos init
        Blesses existing folder as a project.

    2. WORKFLOW
    -----------
    cos export [-s]         Open Export folder
    cos sync                Sync Notes <-> Obsidian
    cos travel              Copy project to External Drive
    cos resurrect "Name"    Restore from Archive

    3. MAINTENANCE
    --------------
    cos clean [-t Path]     Sort loose files
    cos sort-exports        Sort Inbox -> Timeline
    cos thumbs              Update Gallery
    """
    
    parser = argparse.ArgumentParser(description=help_text, formatter_class=RawTextHelpFormatter, usage="cos <command> [options]")
    subparsers = parser.add_subparsers(dest="command", title="Commands")
    
    # NEW
    p_new = subparsers.add_parser("new", help="Spawn Project")
    p_new.add_argument("name", type=str)
    p_new.add_argument("-c", "--category", type=str, default="Video")
    p_new.add_argument("-s", "--simple", action="store_true")
    p_new.add_argument("-d", "--date", type=str)
    p_new.add_argument("--client", type=str)

    # CLONE (NEW!)
    p_clone = subparsers.add_parser("clone", help="Clone Git Repo")
    p_clone.add_argument("url", type=str)
    p_clone.add_argument("-c", "--category", type=str, default="Code") # Default Code for clones
    p_clone.add_argument("--client", type=str)
    p_clone.add_argument("-d", "--date", type=str)

    # INIT
    subparsers.add_parser("init", help="Adopt folder")

    # EXPORT
    p_exp = subparsers.add_parser("export", help="Open Exports")
    p_exp.add_argument("-s", "--simple", action="store_true")

    # UTILS
    subparsers.add_parser("sync", help="Sync Notes")
    subparsers.add_parser("thumbs", help="Update Gallery")
    p_clean = subparsers.add_parser("clean", help="Sort Files")
    p_clean.add_argument("-t", "--target", type=str)
    subparsers.add_parser("sort-exports", help="Sort Inbox")
    subparsers.add_parser("travel", help="Copy to Shuttle")
    p_res = subparsers.add_parser("resurrect", help="Restore Archive")
    p_res.add_argument("name", type=str)

    args = parser.parse_args()

    if args.command == "new": cmd_new(args)
    elif args.command == "clone": cmd_clone(args)
    elif args.command == "init": cmd_init(args)
    elif args.command == "export": cmd_export(args)
    elif args.command == "sync": cmd_sync(args)
    elif args.command == "thumbs": cmd_thumbs(args)
    elif args.command == "clean": cmd_clean(args)
    elif args.command == "sort-exports": cmd_sort_exports(args)
    elif args.command == "travel": cmd_travel(args)
    elif args.command == "resurrect": cmd_resurrect(args)
    else: parser.print_help()

if __name__ == "__main__":
    main()